---
title: "Module 4 — Solve LP Model Using R"
author: "Tara Jameel_811438843"
output:
  html_document:
    toc: true
    toc_depth: 2
    number_sections: true
  pdf_document:
    toc: true
    number_sections: true
---

# Overview

This R Markdown provides a complete solution to the Weigelt Corporation production planning linear program using lpSolve in R, as outlined in the Module 4 instructions. The document presents a clear formulation of the model—defining decision variables, the objective function, and constraints—followed by a reproducible implementation in R. It then reports the results and interpretation, including the optimal production plan, plant utilization, storage usage, and profit levels, and concludes with a well-organized summary table of the solution.

# Problem Statement (from Module 4)

- Three plants (1, 2, 3) with excess capacities of 750, 900, and 450 units/day.
- Three product sizes: Large (L), Medium (M), Small (S).
- Net unit profits: L = $420, M = $360, S = $300.
- Plant storage (sq ft): P1 = 13,000, P2 = 12,000, P3 = 5,000.
- Storage per unit (sq ft): L = 20, M = 15, S = 12.
- Demand caps/day: L ≤ 900, M ≤ 1,200, S ≤ 750.
- **Equal utilization rule**: each plant must use the **same percentage** (t) of its capacity.

**Goal:** Maximize total daily profit.

# LP Formulation (plain-text math)

Let x_{p,s} be the number of units of size s ∈ {L, M, S} produced at plant p ∈ {1,2,3}.
Let t be the common utilization fraction of excess capacity (0 ≤ t ≤ 1).

**Decision variables (10 total):**
x = (x_{1L}, x_{1M}, x_{1S}, x_{2L}, x_{2M}, x_{2S}, x_{3L}, x_{3M}, x_{3S}, t)

**Objective (maximize profit):**
max 420 Σ_p x_{pL} + 360 Σ_p x_{pM} + 300 Σ_p x_{pS}

**Constraints:**

1. **Equal utilization at each plant p:**
Σ_s x_{p,s} - Cap_p * t = 0  (p=1,2,3)
where Cap = (750, 900, 450).

2. **Storage limits at each plant p:**
20 x_{pL} + 15 x_{pM} + 12 x_{pS} ≤ Storage_p
with Storage = (13000, 12000, 5000).

3. **Demand caps by size s:**
Σ_p x_{pL} ≤ 900,   Σ_p x_{pM} ≤ 1200,   Σ_p x_{pS} ≤ 750.

4. **Bounds:** nonnegativity by default in `lpSolve` (x_{p,s} ≥ 0, t ≥ 0), and add explicit constraint t ≤ 1.

# R Implementation

```{r setup, message=FALSE, warning=FALSE}
# Install once if needed:
# install.packages("lpSolve")

library(lpSolve)
library(scales)  # for dollar()
```

## Build the model matrices

```{r}
# Plants and sizes
plants <- c("P1","P2","P3")
sizes  <- c("L","M","S")

cap      <- c(750, 900, 450)
storage  <- c(13000, 12000, 5000)
profit   <- c(L=420, M=360, S=300)
stor_per <- c(L=20,  M=15,  S=12)
demand   <- c(L=900, M=1200, S=750)

# Variable order: x1L, x1M, x1S, x2L, x2M, x2S, x3L, x3M, x3S, t
var_names <- c(paste0("x", rep(1:3, each=3), rep(c("L","M","S"), times=3)), "t")
n_vars <- length(var_names)

# Objective coefficients (maximize -> lpSolve uses "max")
obj <- c(rep(profit[c("L","M","S")], times=3), 0)  # t has 0 profit

# Constraint matrices
A <- NULL
dir <- c()
rhs <- c()

# 1) Equal utilization: sum_s x_{p,s} - cap_p * t = 0, for p=1..3
for (p in 1:3) {
  row <- rep(0, n_vars)
  # x for plant p occupy positions ((p-1)*3+1) : (p*3)
  row[((p-1)*3+1):(p*3)] <- 1
  row[n_vars] <- -cap[p]  # coefficient on t
  A   <- rbind(A, row)
  dir <- c(dir, "==")
  rhs <- c(rhs, 0)
}

# 2) Storage per plant: 20 x_L + 15 x_M + 12 x_S <= storage_p
for (p in 1:3) {
  row <- rep(0, n_vars)
  row[((p-1)*3+1):(p*3)] <- stor_per[c("L","M","S")]
  A   <- rbind(A, row)
  dir <- c(dir, "<=")
  rhs <- c(rhs, storage[p])
}

# 3) Demand caps by size across all plants
# For each size s, sum_p x_{p,s} <= demand_s
for (s_idx in 1:3) {
  row <- rep(0, n_vars)
  # columns with this size across plants are s_idx, s_idx+3, s_idx+6
  row[c(s_idx, s_idx+3, s_idx+6)] <- 1
  A   <- rbind(A, row)
  dir <- c(dir, "<=")
  rhs <- c(rhs, demand[s_idx])
}

# 4) Explicit bound for t <= 1 (since some lpSolve builds don't accept lower/upper args)
row <- rep(0, n_vars); row[n_vars] <- 1
A   <- rbind(A, row)
dir <- c(dir, "<=")
rhs <- c(rhs, 1)
```

## Solve

```{r}
lp_out <- lp(direction = "max",
             objective.in = obj,
             const.mat   = A,
             const.dir   = dir,
             const.rhs   = rhs,
             # Leave defaults: nonnegativity bounds apply (x >= 0, t >= 0)
             compute.sens = FALSE,
             transpose.constraints = FALSE)

stopifnot(lp_out$status == 0)  # 0 = success
opt_value <- lp_out$objval
solution  <- setNames(lp_out$solution, var_names)

opt_value
solution
```

## results

```{r}
# tidy x variables
x_vals <- solution[1:9]
plan <- data.frame(
  Plant = rep(plants, each = 3),
  Size  = rep(c("Large","Medium","Small"), times = 3),
  Units = as.numeric(x_vals)
)

# Summaries
utilization_t <- solution["t"]
by_plant_units <- aggregate(Units ~ Plant, plan, sum)
by_size_units  <- aggregate(Units ~ Size,  plan, sum)

list(
  `Optimal Profit ($/day)` = opt_value,
  `Common Utilization t`   = utilization_t,
  `Units by Plant`         = by_plant_units,
  `Units by Size`          = by_size_units
)
```

# Results & Interpretation

```{r}
knitr::kable(plan, caption = "Optimal Production Plan (units per day)")
```

- **Optimal daily profit**: `r dollar(opt_value)`  
- **Common capacity utilization (t)**: `r round(utilization_t, 6)`  
- **Total units by plant** (should equal `t * capacity` for each plant):
```{r}
merge(by_plant_units,
      data.frame(Plant=plants, Capacity=cap, `t*Capacity`=cap*utilization_t),
      by="Plant")
```
- **Total units by size vs. demand caps**:
```{r}
merge(by_size_units,
      data.frame(Size=c("Large","Medium","Small"),
                 Demand=c(900,1200,750)),
      by="Size")
```

###Conclusion

The storage limits at each plant are the true bottleneck, restricting output before customer demand is reached.
The equal-utilization requirement is satisfied through the variable t, which keeps every plant operating at the same proportion of its capacity.
Demand ceilings do not constrain the solution—the limiting factors are storage and utilization rules.
Increasing available storage space—particularly at Plant 3—would allow more production and raise overall profit.
